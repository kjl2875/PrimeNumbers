2017-11-04 First Release to Git

// 이론식 (아리스토텔레스의 체)

for(i=0; ; i++)
	m[i] = 2 + i;

for(i=0; ; i++)
	if( m[i] != 0 )
		m[i + m[i] * n] = 0;

for(i=0; ; i++)
	if( m[i] != 0 )
		output(m[i]);


(i는 정수, m은 메모리배열, n은 자연수)

// 구현노트

이론식대로 무한정으로 할 수 없으며, UULONG_MAX가 이론상 한계임.
프로그램을 실행하기 전 UULONG_MAX * 8Bytes(128EBytes)만큼의 메모리 확보는 현재 주기억장치로는 불가능함.
단, 이론적으로 비용을 많이 들인 하드웨어 클러스터링 시스템에 복잡성이 많이 증가한 프로그램 로직이라면 가능함.
이론식의 의도는 64bit보다 훨씬 큰 값도 구하는 것에 있으며, 예를 들어서 1Gbit가 있음.
하지만 현재 64bit를 구하는것도 1Gbit에 비해서 시간이 걸림.

// 이론식

n = 2;
c = 0;
m = [];
p = [];

BEGIN:

f = true;
for(i=0; i<c; i++)
	if(m[i] == n)
		m[i] += p[i];
		f = false;

IF f is true THEN p.push n, m.push n+n, output(n), c = c+1

n = n + 1;

goto BEGIN:

Note) 기존 이론식에서 각각의 소수를 뽑아내는데 걸리는 시간편차가 적을 것 같은 방법으로 변형. 이전식 방식 그대로 개선하게 되면 메모리 초기화 과정에서 꽤 많은 대기시간이 있을 것으로 예상됨.

// 구현노트

체감상 결과속도가 이전과 비슷한것 같음
중간에 프로그램을 종료하면 이어서 진행불가.
