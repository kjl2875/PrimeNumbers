2017-11-04 First Release to Git

// 이론식 (아리스토텔레스의 체)

for(i=0; ; i++)
	m[i] = 2 + i;

for(i=0; ; i++)
	if( m[i] != 0 )
		m[i + m[i] * n] = 0;

for(i=0; ; i++)
	if( m[i] != 0 )
		output(m[i]);


(i는 정수, m은 메모리배열, n은 자연수)

// 구현노트

이론식대로 무한정으로 할 수 없으며, UULONG_MAX가 이론상 한계임.
프로그램을 실행하기 전 UULONG_MAX * 8Bytes(128EBytes)만큼의 메모리 확보는 현재 주기억장치로는 불가능함.
단, 이론적으로 비용을 많이 들인 하드웨어 클러스터링 시스템에 복잡성이 많이 증가한 프로그램 로직이라면 가능함.
이론식의 의도는 64bit보다 훨씬 큰 값도 구하는 것에 있으며, 예를 들어서 1Gbit가 있음.
하지만 현재 64bit를 구하는것도 1Gbit에 비해서 시간이 걸림.

// 이론식

n = 2;
c = 0;
m = [];
p = [];

BEGIN:

f = true;
for(i=0; i<c; i++)
	if(m[i] == n)
		m[i] += p[i];
		f = false;

IF f is true THEN p.push n, m.push n+n, output(n), c = c+1

n = n + 1;

goto BEGIN:

Note) 기존 이론식에서 각각의 소수를 뽑아내는데 걸리는 시간편차가 적을 것 같은 방법으로 변형. 이전식 방식 그대로 개선하게 되면 메모리 초기화 과정에서 꽤 많은 대기시간이 있을 것으로 예상됨.

// 구현노트

체감상 결과속도가 이전과 비슷한것 같음
파일로 저장/불러오기 기능을 추가해서, 프로그램이 종료되어도 이어서 계속 실행 가능하도록 구현.
처리속도를 위한 OPENMP 활용: http://sosal.kr/466
그러나 이걸 사용하려면 for에 자주쓰이는 i자료형을 size_t로는 못쓰고, signed int로 써야됨.
아직까지는 signed int max에 도달하려면 시간이 많이 걸리는 편이라 동작이 유효하나, 처리속도가 충분히 빨라지면 값 한계치를 금방 넘어버리기 때문에 다른방법을 찾아야됨.

// 구현노트

저장 / 불어오기 기능을 추가하여, 프로그램 종료 이후에도 연산수행을 이어서 진행할 수 있도록 함.
사용법을 따르고, 저장한 파일데이터를 수정하지 않으면 안전하게 동작할 수 있음.
최대 소수크기 한계점과 연산속도의 과제가 남아있음.
2017-11-05 Version 1.0 Release